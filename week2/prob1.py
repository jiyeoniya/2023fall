# 现有一个正整数7.拆分方法有..
# 1 + 1 + 1 + 1 + 1 + 1 + 1 = 7
# 2 + 2 + 3 = 7
# 3 + 3 + 1 = 7
# ...等
# 现在面临的问题是怎么拆封才能让他们的乘积最大化？
#
# 我们目前可以知道的是，如果想要乘积最大化的条件有
# 尽可能的避开1，因为任何数乘以1 都不会发生改变
#
# 两个数的间隔尽可能小 （比如7 拆分成2 + 5 和 3 + 4 。明显间隔小的3、4乘积最大）
#
# 尽可能多的分解（参考次方运算）
#
# 举个例子
# 对于1、2、3拆分后的结果乘积总比原来的数小
#
# 对于4，因为要避开1，所以只能 拆分为2 + 2 。且 2 * 2 = 2 + 2
#
# 对于5，只能拆分成2 + 3 ，乘积为6
#
# 对于6，拆分为3 + 3 的乘积要大于 2 + 2 + 2
#
# 对于7，拆分 4 + 3 的乘积最大(2 + 2 + 3)
#
# 对于8，拆分 3 + 3 + 2 的乘积大于 4 + 4
#
# 对于9，3 + 3 + 3的乘积最大
#
# 对于10，2 + 3 + 2 + 3 的乘积大于5 + 5
#
# 通过上面的规律我们不难发现，如果想要乘积最大化，需要尽可能的多拆分3，其次是2。 不要出现1 ！ ！ ！
# 所以我们可以对3进行求余，有三种情况
# - 可以整数(余数为0) 如9： 3 + 3 + 3
#
# - 余数为1： 如7： 因为不能出现1，所以不可以拆分成3 + 3 + 1。所以可以选择3 + 4 即 3 + 2 + 2
#
# - 余数为2： 如11: 3 + 3 + 3 + 2

res = []

def fun(n):
    global res
    if n < 5:
        return n
    a, b = divmod(n, 3)
    if b == 0:
        res = [3] * a
        return 3 ** a
    elif b == 1:
        res = [3] * (a - 1) + [2] * 2
        return 3 ** (a - 1) * 4
    elif b == 2:
        res = [3] * a + [2]
        return 3 ** a * 2


fun(2001)
print(res)
